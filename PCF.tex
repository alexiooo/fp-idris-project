
\section{The Language PCF}

This section is intended as a quick introduction to the language PCF. The reader may consult \cite{LambdaNotes} for a more detailed introduction.

\subsection{Types and Terms}

PCF is a programming language that is very similar to the simply typed lambda-calculus. Instead of type variables, it has concrete type $\mbf{bool}$ and $\mbf{nat}$. It also has the classical type constructors $\to$, $\times$ and $1$. Formally, types are defined by the following BNF

\[ A, B := \mbf{bool} \sep \mbf{nat} \sep A\to B \sep A\times B \sep 1. \]

The terms for PCF are those of the simply-typed lambda calculus, plus some concrete terms. In BNF:

\begin{align*}
    M, N, P := x &\sep MN \sep \lambda x^A.M \sep \langle M, N\rangle \sep \pi_1M \sep \pi_2M \sep * \\
    &\sep \mbf{T} \sep \mbf{F} \sep \mbf{zero} \sep \mbf{succ}\,(M) \sep \mbf{pred}\,(M) \\
    &\sep \mbf{iszero}\,(M) \sep \mbf{if}\,M\,\mbf{then}\,N\,\mbf{else}\,P \sep \mbf{Y}(M).
\end{align*}

The $\mbf{Y}$ constructor returns a fixpoint of the given term. It is what makes the language Turing complete. For example, the addition function can be defined as

\[ + := Y(\lambda f^{\mbf{nat}\to\mbf{nat}}m^\mbf{nat}n^\mbf{nat}.\mbf{if}\,\mbf{iszero}(m)\,\mbf{then}\,n\,\mbf{else}\,\mbf{succ}(f \mbf{pred}(m) n)). \]

\subsection{Typing rules}

The reader may notice that among the well-formed terms, some do not make any sense. For example, terms such as $\mbf{iszero}(\mbf{T})$ or $\pi_1(\lambda x^\mbf{nat}.x)$ do not make sense. We should thus specify a type for each term and specify which constructions can be applied to which types.



 \begin{prooftree}
 \AxiomC{}
 \UnaryInfC{$\Gamma, x:A \proves x:A$}
 \end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\proves M:A\to B\qquad \Gamma\proves N:A$}
\UnaryInfC{$\Gamma\proves MN:B$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\proves M:A\times B$}
\UnaryInfC{$\Gamma\proves\pi_1M:A$}
\end{prooftree}


\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \proves * : 1$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma, x:A\proves M:B$}
\UnaryInfC{$\Gamma\proves\lambda x^A.M : A\to B$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\proves M:A\times B$}
\UnaryInfC{$\Gamma\proves\pi_2M:B$}
\end{prooftree}



\begin{prooftree}
\AxiomC{$\Gamma\proves M:A \qquad \Gamma\proves N:B$}
\UnaryInfC{$\Gamma\proves \langle M,N\rangle:A\times B$}
\end{prooftree}

%% include PCF typing rules

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \proves \mathbf{T} : \mathbf{bool}$}
\end{prooftree}  

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \proves \mathbf{F} : \mathbf{bool}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \proves M : A \to A$}
\UnaryInfC{$\Gamma \proves \mathbf{Y}(M) : A$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \proves \mathbf{zero} : \mathbf{nat}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \proves M : \mathbf{nat}$}
\UnaryInfC{$\Gamma \proves \mathbf{succ}(M) : \mathbf{nat}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \proves M : \mathbf{nat}$}
\UnaryInfC{$\Gamma \proves \mathbf{pred}(M) : \mathbf{nat}$}
\end{prooftree}

\subsection{Reduction}

TBA.

\subsubsection{Small-step Reduction}

TBA.

\subsubsection{Big-step Reduction}

TBA.