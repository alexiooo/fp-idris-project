\subsection{Implementing Terms}

\begin{hidden}
module Lib.PrimePCF.Terms

import public Lib.Types

import public Data.Fin  -- needed publically, since we publically export types that reference Fin

%default total
\end{hidden}

We now want to define terms. We use de Bruijn indices to represent bound variables.
This is an elegant way to deal with alpha-equivalence.

\begin{code}
public export
Var : Nat -> Type
Var = Fin
\end{code}

We also keep track of (an upper bound on) free variables in the type:
\lstinline{PCFTerm} n encodes terms with at most n free variables.

\begin{code}
public export
data PCFTerm : Nat -> Type where
  V          : Var k -> PCFTerm k                                -- variables
  L          : PCFType -> PCFTerm (S k) -> PCFTerm k             -- lambda
  IfThenElse : PCFTerm k -> PCFTerm k -> PCFTerm k -> PCFTerm k  -- if-then-else construct
  App        : PCFTerm k -> PCFTerm k -> PCFTerm k               -- application
  Pair       : PCFTerm k -> PCFTerm k -> PCFTerm k               -- pairing
  Fst        : PCFTerm k -> PCFTerm k                            -- first projection
  Snd        : PCFTerm k -> PCFTerm k                            -- second projection
  Succ       : PCFTerm k -> PCFTerm k                            -- successor
  Pred       : PCFTerm k -> PCFTerm k                            -- predecessor
  IsZero     : PCFTerm k -> PCFTerm k                            -- iszero predicate
  Y          : PCFTerm k -> PCFTerm k                            -- fixpoint / Y-combinator
  T          : PCFTerm k                                         -- true
  F          : PCFTerm k                                         -- false
  Zero       : PCFTerm k                                         -- zero
  Unit       : PCFTerm k                                         -- unit value (*)
\end{code}

Of special interest are the closed terms, those without any free variables

\begin{code}
public export
ClosedPCFTerm : Type
ClosedPCFTerm = PCFTerm 0
\end{code}

Remember that the type only gives an upper bound, so an inhabitant of say
\lstinline{PCFType 3} might still be closed.

The following will try to strengthen any such term. This really is just a
wrapper around Fin.strengthen, with straightforward recursive cases,
so we detail only variables and lambdas.

\begin{code}
strengthen : {k : _} -> PCFTerm (S k) -> Maybe (PCFTerm k)
strengthen (V v)              = map V          $ Fin.strengthen v
strengthen (L t m)            = map (L t)      $ strengthen m
strengthen (IfThenElse m n p) = map IfThenElse (strengthen m) <*> strengthen n <*> strengthen p
strengthen (App m n)          = map App        (strengthen m) <*> strengthen n
strengthen (Pair m n)         = map Pair       (strengthen m) <*> strengthen n
strengthen (Fst m)            = map Fst        $ strengthen m
strengthen (Snd m)            = map Snd        $ strengthen m
strengthen (Succ m)           = map Succ       $ strengthen m
strengthen (Pred m)           = map Pred       $ strengthen m
strengthen (IsZero m)         = map IsZero     $ strengthen m
strengthen (Y m)              = map Y          $ strengthen m
strengthen T                  = Just T
strengthen F                  = Just F
strengthen Zero               = Just Zero
strengthen Unit               = Just Unit
\end{code}

\begin{code}
public export
tryClose : {k : _} -> PCFTerm k -> Maybe ClosedPCFTerm
tryClose {k} t = case k of
                 0     => Just t
                 (S l) => strengthen t >>= tryClose
\end{code}

As for types, we want terms to be comparable. The important case is
lambda-abstraction. We are using de Bruijn indices, which make comparing terms
very easy.

\begin{code}
public export partial
implementation Eq (PCFTerm k) where
  V v              == V w              = v == w
  L a m            == L b n            = a == b && m == n
  IfThenElse m n p == IfThenElse q r s = m == q && n == r && p == s
  App m n          == App p q          = m == p && n == q
  Pair m n         == Pair p q         = m == p && n == q
  Fst m            == Fst n            = m == n
  Snd m            == Snd n            = m == n
  Succ m           == Succ n           = m == n
  Pred m           == Pred n           = m == n
  IsZero m         == IsZero n         = m == n
  Y m              == Y n              = m == n
  T                == T                = True
  F                == F                = True
  Zero             == Zero             = True
  Unit             == unit             = True
  _                == _                = False
\end{code}

We can also implement a show function. The implementation in itself is not
interesting, so we omit the details.

\begin{hidden}
public export
Show (PCFTerm k) where
  show (V x)              = show x
  show (L t m)            = "(λ" ++ show t ++ "." ++ show m ++ ")"
  show (IfThenElse m n p) = "if " ++ show m ++ " then " ++ show n ++ " else " ++ show p
  show (App m n)          = "(" ++ show m ++ show n ++ ")"
  show (Pair m n)         = "<" ++ show m ++ ", " ++ show n ++ ">"
  show (Fst m)            = "π₁(" ++ show m ++ ")"
  show (Snd m)            = "π₂(" ++ show m ++ ")"
  show (Succ m)           = "succ (" ++ show m ++ ")"
  show (Pred m)           = "pred (" ++ show m ++ ")"
  show (IsZero m)         = "iszero (" ++ show m ++ ")"
  show (Y m)              = "Y(" ++ show m ++ ")"
  show T                  = "T"
  show F                  = "F"
  show Zero               = "zero"
  show Unit               = "*"
\end{hidden}
